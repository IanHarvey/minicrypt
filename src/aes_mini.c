/*
 * This program is placed into the public domain
 * by its author, Ian Harvey.
 * Note there is NO WARRANTY of any kind.
 */

#include "aes_mini.h"

#include <assert.h>

static const uint32_t rcon[10] = {
  0x01000000, 0x02000000, 0x04000000, 0x08000000,
  0x10000000, 0x20000000, 0x40000000, 0x80000000,
  0x1B000000, 0x36000000,
};

static uint32_t getU32( const uint8_t *pt )
{
  return (pt[0] << 24) | (pt[1] << 16) | (pt[2] << 8) | pt[3];
}

static void putU32( uint8_t *ct, uint32_t st )
{
  ct[0] = (uint8_t)(st >> 24);
  ct[1] = (uint8_t)(st >> 16);
  ct[2] = (uint8_t)(st >>  8);
  ct[3] = (uint8_t)(st);
}

/* Encryption code ---------------------------------------------------- */

static const uint16_t Sx0201[256] = 
{
    0xC663, 0xF87C, 0xEE77, 0xF67B, 0xFFF2, 0xD66B, 0xDE6F, 0x91C5, 
    0x6030, 0x0201, 0xCE67, 0x562B, 0xE7FE, 0xB5D7, 0x4DAB, 0xEC76, 
    0x8FCA, 0x1F82, 0x89C9, 0xFA7D, 0xEFFA, 0xB259, 0x8E47, 0xFBF0, 
    0x41AD, 0xB3D4, 0x5FA2, 0x45AF, 0x239C, 0x53A4, 0xE472, 0x9BC0, 
    0x75B7, 0xE1FD, 0x3D93, 0x4C26, 0x6C36, 0x7E3F, 0xF5F7, 0x83CC, 
    0x6834, 0x51A5, 0xD1E5, 0xF9F1, 0xE271, 0xABD8, 0x6231, 0x2A15, 
    0x0804, 0x95C7, 0x4623, 0x9DC3, 0x3018, 0x3796, 0x0A05, 0x2F9A, 
    0x0E07, 0x2412, 0x1B80, 0xDFE2, 0xCDEB, 0x4E27, 0x7FB2, 0xEA75, 
    0x1209, 0x1D83, 0x582C, 0x341A, 0x361B, 0xDC6E, 0xB45A, 0x5BA0, 
    0xA452, 0x763B, 0xB7D6, 0x7DB3, 0x5229, 0xDDE3, 0x5E2F, 0x1384, 
    0xA653, 0xB9D1, 0x0000, 0xC1ED, 0x4020, 0xE3FC, 0x79B1, 0xB65B, 
    0xD46A, 0x8DCB, 0x67BE, 0x7239, 0x944A, 0x984C, 0xB058, 0x85CF, 
    0xBBD0, 0xC5EF, 0x4FAA, 0xEDFB, 0x8643, 0x9A4D, 0x6633, 0x1185, 
    0x8A45, 0xE9F9, 0x0402, 0xFE7F, 0xA050, 0x783C, 0x259F, 0x4BA8, 
    0xA251, 0x5DA3, 0x8040, 0x058F, 0x3F92, 0x219D, 0x7038, 0xF1F5, 
    0x63BC, 0x77B6, 0xAFDA, 0x4221, 0x2010, 0xE5FF, 0xFDF3, 0xBFD2, 
    0x81CD, 0x180C, 0x2613, 0xC3EC, 0xBE5F, 0x3597, 0x8844, 0x2E17, 
    0x93C4, 0x55A7, 0xFC7E, 0x7A3D, 0xC864, 0xBA5D, 0x3219, 0xE673, 
    0xC060, 0x1981, 0x9E4F, 0xA3DC, 0x4422, 0x542A, 0x3B90, 0x0B88, 
    0x8C46, 0xC7EE, 0x6BB8, 0x2814, 0xA7DE, 0xBC5E, 0x160B, 0xADDB, 
    0xDBE0, 0x6432, 0x743A, 0x140A, 0x9249, 0x0C06, 0x4824, 0xB85C, 
    0x9FC2, 0xBDD3, 0x43AC, 0xC462, 0x3991, 0x3195, 0xD3E4, 0xF279, 
    0xD5E7, 0x8BC8, 0x6E37, 0xDA6D, 0x018D, 0xB1D5, 0x9C4E, 0x49A9, 
    0xD86C, 0xAC56, 0xF3F4, 0xCFEA, 0xCA65, 0xF47A, 0x47AE, 0x1008, 
    0x6FBA, 0xF078, 0x4A25, 0x5C2E, 0x381C, 0x57A6, 0x73B4, 0x97C6, 
    0xCBE8, 0xA1DD, 0xE874, 0x3E1F, 0x964B, 0x61BD, 0x0D8B, 0x0F8A, 
    0xE070, 0x7C3E, 0x71B5, 0xCC66, 0x9048, 0x0603, 0xF7F6, 0x1C0E, 
    0xC261, 0x6A35, 0xAE57, 0x69B9, 0x1786, 0x99C1, 0x3A1D, 0x279E, 
    0xD9E1, 0xEBF8, 0x2B98, 0x2211, 0xD269, 0xA9D9, 0x078E, 0x3394, 
    0x2D9B, 0x3C1E, 0x1587, 0xC9E9, 0x87CE, 0xAA55, 0x5028, 0xA5DF, 
    0x038C, 0x59A1, 0x0989, 0x1A0D, 0x65BF, 0xD7E6, 0x8442, 0xD068, 
    0x8241, 0x2999, 0x5A2D, 0x1E0F, 0x7BB0, 0xA854, 0x6DBB, 0x2C16, 
};

static uint32_t Te0(uint8_t idx)
{
  uint32_t s0201 = Sx0201[idx];
  uint32_t s01 = s0201 & 0xFF;
  uint32_t s03 = s01 ^ (s0201 >> 8);
  return (s0201 << 16) ^ (s01 << 8) ^ s03;
}

#define ROR(w,l) ( ((w)>>(l)) | ((w)<<(32-(l))) ) 

static uint32_t Te0123(uint32_t w0, uint32_t w1, uint32_t w2, uint32_t w3)
{
  w0 = Te0(w0 >> 24);
  w1 = Te0(w1 >> 16);
  w2 = Te0(w2 >> 8);
  w3 = Te0(w3);
  return w0 ^ ROR(w1,8) ^ ROR(w2,16) ^ ROR(w3, 24);
}

static uint32_t Sx01(uint32_t idx)
{
  return Sx0201[idx & 0xFF] & 0xFF;
}

static void encLastRound(uint8_t *ct, uint32_t w0, uint32_t w1, uint32_t w2, uint32_t w3, uint32_t rk)
{
  uint32_t tmp = 
    (Sx01(w0 >> 24) << 24)
    | (Sx01(w1 >> 16) << 16)
    | (Sx01(w2 >> 8)  << 8)
    |  Sx01(w3);
  putU32(ct, tmp ^ rk); 
}

#if !defined(AESMINI_128BIT_ONLY) || !defined(AESMINI_ENCRYPT_ONLY)
static uint32_t SxBytes(uint32_t w0)
{
  return (Sx01(w0 >> 24) << 24)
    | (Sx01(w0 >> 16) << 16)
    | (Sx01(w0 >> 8)  << 8)
    |  Sx01(w0);
}
#endif

static uint32_t SxBytesRot8(uint32_t w0)
{
  return  (Sx01(w0 >> 16) << 24)
    | (Sx01(w0 >> 8 ) << 16)
    | (Sx01(w0      )  << 8)
    |  Sx01(w0 >> 24);
}

void AESMini_Init_Encrypt(AESMini_keys *ctx, const uint8_t *keyData, int nkeybytes)
{
  uint32_t *rk = ctx->roundkeys;
  int keyBits = nkeybytes << 3;
  int i=0;

  for (i=0; i < keyBits/32; i++)
    rk[i] = getU32(keyData + 4*i);

  if (keyBits == 128) {
    for (i=0; i<40; i++) {
      if ((i&3)==0)
	  rk[i+4] = rk[i] ^ SxBytesRot8(rk[i+3]) ^ rcon[i/4];
      else
	rk[i+4] = rk[i] ^ rk[i+3];
    }
    ctx->nrounds=10;
  }

#ifndef AESMINI_128BIT_ONLY
  else if (keyBits == 192) {
    for (i=0; i<46 ; i++) {
      if ((i%6)==0)
	rk[i+6] = rk[ i] ^ SxBytesRot8(rk[i+5]) ^ rcon[i/6];
      else
	rk[i+6] = rk[i] ^ rk[i+5];
    }
    ctx->nrounds=12;
  }

  else if (keyBits == 256) {
    for (i=0; i<52; i++) {
      if ((i%8)==0)
	rk[i+8] = rk[i] ^ SxBytesRot8(rk[i+7]) ^ rcon[i/8];
      else if ((i % 8)== 4)
	rk[i+8] = rk[i] ^ SxBytes(rk[i+7]);
      else
	rk[i+8] = rk[i] ^ rk[i+7];
    }
    ctx->nrounds=14;
  }
#endif

}


void AESMini_ECB_Encrypt(AESMini_ctx *ctx, const uint8_t *pt, uint8_t *ct)
{
  const uint32_t *rk = ctx->enc.roundkeys;
  uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
  int r;

  s0 = getU32(pt     ) ^ rk[0];
  s1 = getU32(pt +  4) ^ rk[1];
  s2 = getU32(pt +  8) ^ rk[2];
  s3 = getU32(pt + 12) ^ rk[3];

  for (r=0; r<(ctx->enc.nrounds-1); r++) {
    rk += 4;
    t0 = Te0123(s0, s1, s2, s3) ^ rk[0];
    t1 = Te0123(s1, s2, s3, s0) ^ rk[1];
    t2 = Te0123(s2, s3, s0, s1) ^ rk[2];
    t3 = Te0123(s3, s0, s1, s2) ^ rk[3];
    s0=t0, s1=t1, s2=t2, s3=t3;
  }

  rk += 4;
  encLastRound(ct,    s0, s1, s2, s3,  rk[0]);
  encLastRound(ct+4,  s1, s2, s3, s0,  rk[1]);
  encLastRound(ct+8,  s2, s3, s0, s1,  rk[2]);
  encLastRound(ct+12, s3, s0, s1, s2,  rk[3]);
}

/* Decryption code ---------------------------------------------------- */

#ifndef AESMINI_ENCRYPT_ONLY

static const uint32_t SiE9DB[256] = {
  0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
  0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
  0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
  0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
  0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
  0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
  0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
  0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
  0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
  0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
  0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
  0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
  0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
  0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
  0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
  0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
  0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
  0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
  0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
  0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
  0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
  0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
  0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
  0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
  0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
  0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
  0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
  0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
  0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
  0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
  0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
  0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
  0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
  0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
  0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
  0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
  0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
  0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
  0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
  0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
  0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
  0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
  0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
  0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
  0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
  0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
  0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
  0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
  0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
  0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
  0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
  0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
  0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
  0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
  0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
  0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
  0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
  0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
  0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
  0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
  0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
  0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
  0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
  0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
};

static uint32_t Td0123(uint32_t w0, uint32_t w1, uint32_t w2, uint32_t w3)
{
  w0 = SiE9DB[(w0 >> 24)        ];
  w1 = SiE9DB[(w1 >> 16) & 0xff ];
  w2 = SiE9DB[(w2 >> 8 ) & 0xff ];
  w3 = SiE9DB[(w3      ) & 0xff ];
  return w0 ^ ROR(w1,8) ^ ROR(w2,16) ^ ROR(w3,24);
}

static uint32_t Si(uint8_t idx)
{
  uint32_t r = SiE9DB[idx];
  r = r ^ (r >> 16);
  return (r ^ (r >> 8)) & 0xFF;   /* Now = Si[idx] */
}

static void decLastRound(uint8_t *pt, uint32_t w0, uint32_t w1, uint32_t w2, uint32_t w3, uint32_t rk)
{
  uint32_t tmp = 
    (Si(w0 >> 24) << 24) |
    (Si(w1 >> 16) << 16) |
    (Si(w2 >>  8) << 8 ) |
    (Si(w3      ) );
  putU32(pt, tmp ^ rk);
}

static uint32_t invMixCol(uint32_t w)
{
  w = SxBytes(w);
  return Td0123(w,w,w,w);
}

static void AESMini_Init_Decrypt(AESMini_keys *ctx, const uint8_t *keyData, int nkeybytes)
{
  int i, j;
  int nkeys;
  uint32_t *rk = ctx->roundkeys;
  uint32_t temp;

  /* expand the cipher key: */
  AESMini_Init_Encrypt(ctx, keyData, nkeybytes);
  /* invert the order of the round keys: */
  nkeys = 4*ctx->nrounds;

  for (i = 0, j = nkeys+3; i < j; i++, j--)
  {
    temp = rk[i]; rk[i] = rk[j^3]; rk[j^3] = temp;
  }
  /* apply the inverse MixColumn transform to all round keys but the first and the last: */
  for (i = 4; i < nkeys; i++)
  {
    rk[i] = invMixCol(rk[i]);
  }
}

void AESMini_ECB_Decrypt(AESMini_ctx *ctx, const uint8_t *ct, uint8_t *pt)
{
  const uint32_t *rk = ctx->dec.roundkeys;
  uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
  int r;

  s0 = getU32(ct     ) ^ rk[0];
  s1 = getU32(ct +  4) ^ rk[1];
  s2 = getU32(ct +  8) ^ rk[2];
  s3 = getU32(ct + 12) ^ rk[3];

  for (r=0; r<(ctx->dec.nrounds-1); r++)
  {
    rk += 4;
    t0 = Td0123(s0, s3, s2, s1) ^ rk[0];
    t1 = Td0123(s1, s0, s3, s2) ^ rk[1];
    t2 = Td0123(s2, s1, s0, s3) ^ rk[2];
    t3 = Td0123(s3, s2, s1, s0) ^ rk[3];
    s0=t0, s1=t1, s2=t2, s3=t3;
  }

  rk += 4;
  decLastRound(pt,    s0, s3, s2, s1, rk[0]);
  decLastRound(pt+4,  s1, s0, s3, s2, rk[1]);
  decLastRound(pt+8,  s2, s1, s0, s3, rk[2]);
  decLastRound(pt+12, s3, s2, s1, s0, rk[3]);
}

#endif  /* AESMINI_ENCRYPT_ONLY */

void AESMini_Init(AESMini_ctx *ctx, const uint8_t *key, int nkeybytes)
{
#ifdef AESMINI_128BIT_ONLY
  assert(nkeybytes==16);
#else
  assert(nkeybytes==16 || nkeybytes==24 || nkeybytes==32);
#endif

  AESMini_Init_Encrypt( &ctx->enc, key, nkeybytes );
#ifndef AESMINI_ENCRYPT_ONLY
  AESMini_Init_Decrypt( &ctx->dec, key, nkeybytes );
#endif
}

/* ----------------------------------------------------------------- */

#ifdef TEST_HARNESS

#include <stdio.h>
#include <string.h>

typedef struct
{
  int keylen;
  uint8_t key[32];
  uint8_t plain[AESMINI_BLOCK_SIZE];
  uint8_t cipher[AESMINI_BLOCK_SIZE];
}
  AES_TV;

static const AES_TV aes_tvs[] =
{
  {
    16,
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
    { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
    { 0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a }
  },

  {
    16,
    { 0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x12 },
    { 0x50, 0x68, 0x12, 0xA4, 0x5F, 0x08, 0xC8, 0x89, 0xB9, 0x7F, 0x59, 0x80, 0x03, 0x8B, 0x83, 0x59 },
    { 0xD8, 0xF5, 0x32, 0x53, 0x82, 0x89, 0xEF, 0x7D, 0x06, 0xB5, 0x06, 0xA4, 0xFD, 0x5B, 0xE9, 0xC9 }
  },

  {
    16,
    { 0xDC, 0xDD, 0xDE, 0xDF, 0xE1, 0xE2, 0xE3, 0xE4, 0xE6, 0xE7, 0xE8, 0xE9, 0xEB, 0xEC, 0xED, 0xEE },
    { 0x23, 0x60, 0x5A, 0x82, 0x43, 0xD0, 0x77, 0x64, 0x54, 0x1B, 0xC5, 0xAD, 0x35, 0x5B, 0x31, 0x29 },
    { 0x6D, 0x96, 0xFE, 0xF7, 0xD6, 0x65, 0x90, 0xA7, 0x7A, 0x77, 0xBB, 0x20, 0x56, 0x66, 0x7F, 0x7F }
  },


#ifndef AESMINI_128BIT_ONLY
  {
    24,
    { 0x78, 0x79, 0x7A, 0x7B, 0x7D, 0x7E, 0x7F, 0x80, 0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8A,
      0x8C, 0x8D, 0x8E, 0x8F, 0x91, 0x92, 0x93, 0x94 },
    { 0x02, 0xAE, 0xA8, 0x6E, 0x57, 0x2E, 0xEA, 0xB6, 0x6B, 0x2C, 0x3A, 0xF5, 0xE9, 0xA4, 0x6F, 0xD6 },
    { 0x8F, 0x67, 0x86, 0xBD, 0x00, 0x75, 0x28, 0xBA, 0x26, 0x60, 0x3C, 0x16, 0x01, 0xCD, 0xD0, 0xD8 }
  },

  {
    32,
    { 0x60, 0x61, 0x62, 0x63, 0x65, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x6D, 0x6F, 0x70, 0x71, 0x72,
      0x74, 0x75, 0x76, 0x77, 0x79, 0x7A, 0x7B, 0x7C, 0x7E, 0x7F, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86 },
    { 0xD2, 0x1E, 0x43, 0x9F, 0xF7, 0x49, 0xAC, 0x8F, 0x18, 0xD6, 0xD4, 0xB1, 0x05, 0xE0, 0x38, 0x95 },
    { 0x9A, 0x6D, 0xB0, 0xC0, 0x86, 0x2E, 0x50, 0x6A, 0x9E, 0x39, 0x72, 0x25, 0x88, 0x40, 0x41, 0xD7 }
  },
#endif /* AESMINI_128BIT_ONLY */
};

static const int aes_tvs_count = sizeof(aes_tvs) / sizeof(AES_TV);

int main(void)
{
  int i, errs=0, total=0;
  uint8_t buf[AESMINI_BLOCK_SIZE];
  AESMini_ctx ctx;

  for( i=0; i<aes_tvs_count; i++ )
  {
    const AES_TV *tv = &aes_tvs[i];
    AESMini_Init(&ctx, tv->key, tv->keylen);
    AESMini_ECB_Encrypt(&ctx, tv->plain, buf);
    if ( memcmp(buf, tv->cipher, AESMINI_BLOCK_SIZE) != 0 )
      errs++;
    total++;

#ifndef AESMINI_ENCRYPT_ONLY
    AESMini_ECB_Decrypt(&ctx, tv->cipher, buf);
    if ( memcmp(buf, tv->plain, AESMINI_BLOCK_SIZE) != 0 )
      errs++;
    total++;
#endif
  }
  printf("%d errors out of %d\n", errs, total);
  return (errs==0) ? 0 : 1;
}

#endif

